/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef MAIN_SHADER_H_
# define MAIN_SHADER_H_

const char *main_shader_glsl =
 "#version 130\n"
 "uniform int F[1];"
 "float v=F[0]/44100./8.;"
 "uniform sampler2D S;"
 "vec3 i=vec3(0.,.01,1.);"
 "vec4 f(vec2 v)"
 "{"
   "return texture2D(S,(v+.5)/textureSize(S,0));"
 "}"
 "const float y=6.36e+06,z=6.38e+06;"
 "const int x=128,m=16;"
 "const float s=.76,e=s*s,t=8000.,l=1200.,n=10.;"
 "const vec3 r=vec3(0.,-y,0.),p=vec3(5.8e-06,1.35e-05,3.31e-05),d=vec3(2e-05),a=d*1.1;"
 "vec4 c,u;"
 "vec3 g;"
 "float w,o;"
 "float h(vec3 v)"
 "{"
   "float i=v.y-400.,z=length(v.xz);"
   "v/=100.;"
   "vec2 y=floor(v.xz),V=y;"
   "float L=10.,m=10.;"
   "for(float b=-1.;b<=1.;b+=1.)"
     "for(float x=-1.;x<=1.;x+=1.)"
       "{"
         "vec2 Z=y+vec2(b,x),X=Z+.5,p=floor(Z/10.);"
         "u=f(p);"
         "float e=dot(Z,Z);"
         "c=f(Z);"
         "X+=(c.yz-.5)*smoothstep(100.,200.,e)*u.x;"
         "float s=abs(X.x-v.x)+abs(X.y-v.z);"
         "if(s<L)"
           "m=L,L=s,V=Z;"
         "else"
           " if(s<m)"
             "m=s;"
       "}"
   "float x=m-L,X=dot(V,V);"
   "c=f(V);"
   "u=f(V/10.);"
   "g=v-vec3(V.x,0.,V.y);"
   "o=step(.8,u.w);"
   "float s=smoothstep(10000.,1000.,z)*(1.-o),Z=s*(1.+2.*smoothstep(.2,1.,u.y));"
   "w=(.3-x)*.5;"
   "i=min(v.y,max(v.y-c.x*Z,w));"
   "return 100.*max(i,length(v)-100.);"
 "}"
 "vec3 C(vec3 v)"
 "{"
   "return normalize(vec3(h(v+i.yxx),h(v+i.xyx),h(v+i.xxy))-h(v));"
 "}"
 "float C(vec3 v,vec3 i,float f,float y)"
 "{"
   "float m=10.,V=f;"
   "for(int x=0;x<199;++x)"
     "{"
       "float s=h(v+i*f);"
       "f+=s*.37;"
       "if(s<.001*f||f>y)"
         "return f;"
       "if(s<m)"
         "m=s,V=f;"
     "}"
   "return V;"
 "}"
 "vec3 b,L,q,Z;"
 "float Y=.5,X=10.;"
 "float W(vec3 v)"
 "{"
   "return mix(max(0.,dot(q,v))/3.,max(0.,pow(dot(q,normalize(v-L)),X)*(X+8.)/24.),Y);"
 "}"
 "vec3 V=normalize(vec3(1.,.8,1.));"
 "float U(in vec3 v)"
 "{"
   "vec3 s=floor(v),V=fract(v);"
   "vec2 i=s.xy+vec2(37.,17.)*s.z+V.xy,Z=textureLod(S,(i+.5)/textureSize(S,0),0.).yx;"
   "return mix(Z.x,Z.y,V.z);"
 "}"
 "float T(in vec3 v)"
 "{"
   "return.55*U(v)+.225*U(v*2.)+.125*U(v*3.99)+.0625*U(v*8.9);"
 "}"
 "float R(vec3 v)"
 "{"
   "float f=T(v*.0004);"
   "f=smoothstep(.44,.64,f);"
   "f*=f*40.;"
   "return f;"
 "}"
 "vec2 Q(vec3 i)"
 "{"
   "float m=max(0.,length(i-r)-y);"
   "vec2 V=vec2(exp(-m/t),exp(-m/l));"
   "const float f=5000.;"
   "if(f<m&&m<10000.)"
     "V.y+=R(i+vec3(23175.7,0.,v*300.))*max(0.,sin(3.1415*(m-f)/f));"
   "return V;"
 "}"
 "float C(in vec3 v,in vec3 V,in float f)"
 "{"
   "vec3 i=v-r;"
   "float s=dot(i,V),m=dot(i,i)-f*f,Z=s*s-m;"
   "if(Z<0.)"
     "return-1.;"
   "float y=sqrt(Z),L=-s-y,X=-s+y;"
   "return L>=0.?L:X;"
 "}"
 "vec3 Q(vec3 v,vec3 i,float f)"
 "{"
   "float s=f/float(m);"
   "vec2 V=vec2(0.);"
   "for(int y=0;y<m;++y)"
     "{"
       "vec3 Z=v+i*float(y)*s;"
       "V+=Q(Z)*s;"
     "}"
   "return exp(-(p*V.x+a*V.y));"
 "}"
 "vec3 Q(vec3 v,vec3 i,float f,vec3 y)"
 "{"
   "vec2 c=vec2(0.,0.);"
   "vec3 Z=vec3(0.),X=vec3(0.);"
   "float L=f/float(x);"
   "for(int b=0;b<x;++b)"
     "{"
       "vec3 w=v+i*float(b)*L;"
       "vec2 u=Q(w)*L;"
       "c+=u;"
       "float r=C(w,V,z);"
       "if(r>0.)"
         "{"
           "float U=r/float(m);"
           "vec2 g=vec2(0.);"
           "for(int Y=0;Y<m;++Y)"
             "{"
               "vec3 t=w+V*float(Y)*U;"
               "g+=Q(t)*U;"
             "}"
           "vec2 Y=g+c;"
           "vec3 t=exp(-(p*Y.x+a*Y.y));"
           "Z+=t*u.x;"
           "X+=t*u.y;"
         "}"
       "else"
         " return vec3(0.);"
     "}"
   "float b=dot(i,V),u=1.+b*b;"
   "vec2 Y=vec2(.0596831*u,.119366*(1.-e)*u/((2.+e)*pow(1.+e-2.*s*b,1.5)));"
   "return y*exp(-(p*c.x+a*c.y))+n*(Z*p*Y.x+X*d*Y.y);"
 "}"
 "float M(float v)"
 "{"
   "return clamp(v,0.,1.);"
 "}"
 "void main()"
 "{"
   "vec2 s=vec2(1280.,720.),i=gl_FragCoord.xy/s*2.-1.;"
   "i.x*=s.x/s.y;"
   "v+=.2*f(gl_FragCoord.xy+v*100.*vec2(17.,39.)).x;"
   "vec3 y=vec3(0.);"
   "b=vec3(mod(v*10.,10000.)-5000.,1000.+500.*sin(v/60.),mod(v*50.,10000.)-5000.);"
   "if(v<64.)"
     "V.y=.1,y.y=5000.;"
   "else"
     " if(v<128.)"
       "{"
         "float m=(v-64.)/64.;"
         "V.y=.1+2.*m*m*m*m;"
       "}"
     "else"
       " if(v<192.)"
         "{"
           "float m=1.-(v-128.)/64.;"
           "V.y=.1+2.*m*m*m*m;"
         "}"
       "else"
         " V.y=.1;"
   "V=normalize(V);"
   "L=normalize(b-y);"
   "vec3 m=normalize(cross(normalize(vec3(.6*(f(vec2(v/16.)).x-.5),1.,0.)),L));"
   "L=mat3(m,normalize(cross(L,m)),L)*normalize(vec3(i,-1.));"
   "vec3 x=vec3(0.);"
   "const float e=50000.;"
   "float u=C(b,L,0.,e);"
   "vec3 t=vec3(0.);"
   "if(u<e)"
     "{"
       "Z=b+L*u;"
       "q=C(Z);"
       "vec3 r=vec3(.3+.2*c.w)+.03*c.xyz;"
       "float g=1.-.3*M(.5*((10.-Z.y)/10.+(1.-w)));"
       "X=200.;"
       "if(o>0.)"
         "{"
           "float p=step(.1,w);"
           "r=.4*mix(vec3(.4,.9,.3)-vec3(.2*f(Z.xz).x),.8*vec3(.6,.8,.2),p);"
           "Y=.5-.5*(1.-p);"
           "X=10.*(1.-p);"
           "g=1.;"
         "}"
       "else"
         " if(Z.y<1.)"
           "r=vec3(.01+.04*step(w,.07))+vec3(.7)*step(.145,w),X=1.;"
         "else"
           ";"
       "r*=g;"
       "x+=r*Q(Z,V,C(Z,V,z))*n*W(V);"
       "vec3 p=vec3(-V.x,V.y,-V.z);"
       "x+=r*Q(Z,p,C(Z,p,z),vec3(0.))*W(p);"
       "x+=r*vec3(.07)*W(normalize(vec3(1.)));"
       "x+=t;"
     "}"
   "else"
     " u=C(b,L,z);"
   "x=Q(b,L,u,x);"
   "gl_FragColor=vec4(pow(x,vec3(1./2.2)),.5);"
 "}";

#endif // MAIN_SHADER_H_
