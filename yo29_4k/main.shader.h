/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef MAIN_SHADER_H_
# define MAIN_SHADER_H_

const char *main_shader_glsl =
 "#version 130\n"
 "uniform float F[1];"
 "float v=F[0];"
 "uniform sampler2D S;"
 "vec3 f=vec3(0.,.01,1.);"
 "vec4 t(vec2 v)"
 "{"
   "return texture2D(S,(v+.5)/textureSize(S,0));"
 "}"
 "const float y=6.36e+06,z=6.38e+06;"
 "const int i=128,x=16;"
 "const float s=.76,e=s*s,l=8000.,n=1200.,m=10.;"
 "const vec3 r=vec3(0.,-y,0.),p=vec3(5.8e-06,1.35e-05,3.31e-05),d=vec3(2e-05),a=d*1.1;"
 "vec4 c,u;"
 "vec3 g;"
 "float w,o;"
 "float h(vec3 v)"
 "{"
   "float f=v.y-400.,z=length(v.xz);"
   "v/=100.;"
   "float y=0.;"
   "f=v.y-y;"
   "vec2 x=floor(v.xz),L=x;"
   "float V=10.,e=10.;"
   "for(float i=-1.;i<=1.;i+=1.)"
     "for(float r=-1.;r<=1.;r+=1.)"
       "{"
         "vec2 Z=x+vec2(i,r),X=Z+.5,n=floor(Z/10.);"
         "u=t(n);"
         "float m=dot(Z,Z);"
         "c=t(Z);"
         "X+=(c.yz-.5)*smoothstep(100.,200.,m)*u.x;"
         "float b=abs(X.x-v.x)+abs(X.y-v.z);"
         "if(b<V)"
           "e=V,V=b,L=Z;"
         "else"
           " if(b<e)"
             "e=b;"
       "}"
   "float r=e-V,X=dot(L,L);"
   "c=t(L);"
   "u=t(L/10.);"
   "g=v-vec3(L.x,0.,L.y);"
   "o=step(.8,u.w);"
   "float m=smoothstep(10000.,1000.,z)*(1.-o),s=m*(1.+2.*smoothstep(.2,1.,u.y));"
   "w=(.3-r)*.5;"
   "float i=max(v.y-y-c.x*s,w);"
   "f=min(f,i);"
   "return 100.*max(f,length(v)-100.);"
 "}"
 "vec3 C(vec3 v)"
 "{"
   "return normalize(vec3(h(v+f.yxx),h(v+f.xyx),h(v+f.xxy))-h(v));"
 "}"
 "float C(vec3 v,vec3 f,float x,float y)"
 "{"
   "float z=10.,L=x;"
   "for(int i=0;i<199;++i)"
     "{"
       "float b=h(v+f*x);"
       "x+=b*.37;"
       "if(b<.001*x||x>y)"
         "return x;"
       "if(b<z)"
         "z=b,L=x;"
     "}"
   "return L;"
 "}"
 "vec3 b,L,q,Z;"
 "float Y=.5,X=10.;"
 "float W(vec3 v)"
 "{"
   "return mix(max(0.,dot(q,v))/3.,max(0.,pow(dot(q,normalize(v-L)),X)*(X+8.)/24.),Y);"
 "}"
 "vec3 V=normalize(vec3(1.,2.*sin(v*.1),1.));"
 "float U(in vec3 v)"
 "{"
   "vec3 f=floor(v),L=fract(v);"
   "vec2 i=f.xy+vec2(37.,17.)*f.z+L.xy,Z=textureLod(S,(i+.5)/textureSize(S,0),0.).yx;"
   "return mix(Z.x,Z.y,L.z);"
 "}"
 "float T(in vec3 i)"
 "{"
   "return.55*U(i)+.225*U(i*2.+v*.4)+.125*U(i*3.99)+.0625*U(i*8.9);"
 "}"
 "float R(vec3 v)"
 "{"
   "float f=T(v*.0004);"
   "f=smoothstep(.44,.64,f);"
   "f*=f*40.;"
   "return f;"
 "}"
 "vec2 Q(vec3 i)"
 "{"
   "float f=max(0.,length(i-r)-y);"
   "vec2 x=vec2(exp(-f/l),exp(-f/n));"
   "const float L=5000.;"
   "if(L<f&&f<10000.)"
     "x.y+=R(i+vec3(23175.7,0.,-v*3000.))*max(0.,sin(3.1415*(f-L)/L));"
   "return x;"
 "}"
 "float C(in vec3 v,in vec3 L,in float f)"
 "{"
   "vec3 i=v-r;"
   "float x=dot(i,L),z=dot(i,i)-f*f,Z=x*x-z;"
   "if(Z<0.)"
     "return-1.;"
   "float y=sqrt(Z),m=-x-y,X=-x+y;"
   "return m>=0.?m:X;"
 "}"
 "vec3 Q(vec3 v,vec3 f,float i)"
 "{"
   "float m=i/float(x);"
   "vec2 r=vec2(0.);"
   "for(int L=0;L<x;++L)"
     "{"
       "vec3 Z=v+f*float(L)*m;"
       "r+=Q(Z)*m;"
     "}"
   "return exp(-(p*r.x+a*r.y));"
 "}"
 "vec3 Q(vec3 v,vec3 f,float b,vec3 y)"
 "{"
   "vec2 r=vec2(0.,0.);"
   "vec3 L=vec3(0.),X=vec3(0.);"
   "float Z=b/float(i);"
   "for(int c=0;c<i;++c)"
     "{"
       "vec3 n=v+f*float(c)*Z;"
       "vec2 t=Q(n)*Z;"
       "r+=t;"
       "float g=C(n,V,z);"
       "if(g>0.)"
         "{"
           "float U=g/float(x);"
           "vec2 u=vec2(0.);"
           "for(int w=0;w<x;++w)"
             "{"
               "vec3 Y=n+V*float(w)*U;"
               "u+=Q(Y)*U;"
             "}"
           "vec2 Y=u+r;"
           "vec3 w=exp(-(p*Y.x+a*Y.y));"
           "L+=w*t.x;"
           "X+=w*t.y;"
         "}"
       "else"
         " return vec3(0.);"
     "}"
   "float w=dot(f,V),n=1.+w*w;"
   "vec2 c=vec2(.0596831*n,.119366*(1.-e)*n/((2.+e)*pow(1.+e-2.*s*w,1.5)));"
   "return y*exp(-(p*r.x+a*r.y))+m*(L*p*c.x+X*d*c.y);"
 "}"
 "float M(float v)"
 "{"
   "return clamp(v,0.,1.);"
 "}"
 "void main()"
 "{"
   "const vec2 f=vec2(640.,360.);"
   "vec2 i=gl_FragCoord.xy/f*2.-1.;"
   "i.x*=f.x/f.y;"
   "v+=.2*t(gl_FragCoord.xy+v*100.*vec2(17.,39.)).x;"
   "vec3 y=vec3(0.);"
   "b=vec3(mod(v*100.,10000.)-5000.,1000.,mod(v*500.,10000.)-5000.);"
   "L=normalize(b-y);"
   "vec3 x=normalize(cross(normalize(vec3(.3*t(vec2(v*.1)).x,1.,0.)),L));"
   "L=mat3(x,normalize(cross(L,x)),L)*normalize(vec3(i,-1.));"
   "vec3 r=vec3(0.);"
   "const float n=50000.;"
   "float s=C(b,L,0.,n);"
   "vec3 e=vec3(0.);"
   "if(s<n)"
     "{"
       "Z=b+L*s;"
       "q=C(Z);"
       "vec3 d=vec3(.3+.2*c.w)+.03*c.xyz;"
       "float u=1.-.3*M(.5*((10.-Z.y)/10.+(1.-w)));"
       "X=200.;"
       "if(o>0.)"
         "{"
           "float l=step(.1,w);"
           "d=.4*mix(vec3(.4,.9,.3)-vec3(.2*t(Z.xz).x),.8*vec3(.6,.8,.2),l);"
           "Y=.5-.5*(1.-l);"
           "X=10.*(1.-l);"
           "u=1.;"
         "}"
       "else"
         " if(Z.y<1.)"
           "d=vec3(.01+.04*step(w,.07))+vec3(.7)*step(.145,w),X=1.;"
         "else"
           ";"
       "d*=u;"
       "r+=d*Q(Z,V,C(Z,V,z))*m*W(V);"
       "vec3 l=vec3(-V.x,V.y,-V.z);"
       "r+=d*Q(Z,l,C(Z,l,z),vec3(0.))*W(l);"
       "r+=d*vec3(.07)*W(normalize(vec3(1.)));"
       "r+=e;"
     "}"
   "else"
     " s=C(b,L,z);"
   "r=Q(b,L,s,r);"
   "gl_FragColor=vec4(pow(r,vec3(1./2.2)),.5);"
 "}";

#endif // MAIN_SHADER_H_
